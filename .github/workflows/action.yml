name: upload-to-ftp
on:
  workflow_dispatch:

jobs:
  upload:
    runs-on: ubuntu-latest
    steps:
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.x"

      - name: Download, extract and upload to FTP (inlined Python)
        env:
          ZIP_URL: "https://github.com/SCPF-Bot/mozilla.android/releases/download/latest/pD2ZOpEeq5.zip"
          ZIP_NAME: "pD2ZOpEeq5.zip"
          EXTRACT_DIR: "extracted"
          FTP_HOST_PORT: "ftp.minefort.com:21"
          FTP_USER: "RYLOU0gwZn"
          FTP_PASS: "gQT90ExX3a"
          REMOTE_BASE_DIR: ""  # set a remote base path here if desired
        run: |
          python3 - <<'PY'
          import os
          import shutil
          import urllib.request
          import zipfile
          import ftplib
          from pathlib import Path

          ZIP_URL = os.environ.get("ZIP_URL")
          ZIP_NAME = os.environ.get("ZIP_NAME", "pD2ZOpEeq5.zip")
          EXTRACT_DIR = os.environ.get("EXTRACT_DIR", "extracted")
          FTP_HOST_PORT = os.environ.get("FTP_HOST_PORT", "ftp.minefort.com:21")
          FTP_USER = os.environ.get("FTP_USER")
          FTP_PASS = os.environ.get("FTP_PASS")
          REMOTE_BASE_DIR = os.environ.get("REMOTE_BASE_DIR", "")

          def parse_host_port(hp: str):
              if ":" in hp:
                  host, port = hp.rsplit(":", 1)
                  try:
                      return host, int(port)
                  except ValueError:
                      return host, 21
              return hp, 21

          def download_zip(url: str, dest: str):
              print(f"Downloading {url} -> {dest}")
              urllib.request.urlretrieve(url, dest)
              print("Download completed.")

          def extract_zip(zip_path: str, extract_to: str):
              print(f"Extracting {zip_path} -> {extract_to}")
              with zipfile.ZipFile(zip_path, "r") as zf:
                  zf.extractall(extract_to)
              print("Extraction completed.")

          def remove_file(path: str):
              try:
                  os.remove(path)
                  print(f"Removed file {path}")
              except FileNotFoundError:
                  print(f"File {path} not found, skipping removal.")

          def ensure_remote_dir(ftp: ftplib.FTP, remote_dir: str):
              """
              Ensure the remote directory exists by creating each segment if necessary.
              Leaves the FTP current working directory at the target directory.
              """
              if not remote_dir:
                  return
              parts = [p for p in remote_dir.replace("\\", "/").split("/") if p]
              # Try to start from root; if not allowed, continue from current working dir
              try:
                  ftp.cwd("/")
              except Exception:
                  pass
              for part in parts:
                  try:
                      ftp.cwd(part)
                  except ftplib.error_perm:
                      try:
                          ftp.mkd(part)
                          ftp.cwd(part)
                      except Exception as e:
                          # Some servers behave differently; attempt to cwd again
                          try:
                              ftp.cwd(part)
                          except Exception:
                              raise RuntimeError(f"Failed to create or enter remote directory '{part}': {e}")

          def upload_directory(ftp: ftplib.FTP, local_dir: str, remote_base: str = ""):
              local_dir = os.path.abspath(local_dir)
              for root, dirs, files in os.walk(local_dir):
                  rel = os.path.relpath(root, local_dir)
                  if rel == ".":
                      remote_dir = remote_base
                  else:
                      # normalize to POSIX path for FTP
                      remote_dir = "/".join(filter(None, [remote_base, rel.replace(os.sep, "/")]))
                  # ensure remote dir exists and cwd into it
                  ensure_remote_dir(ftp, remote_dir)

                  for filename in files:
                      local_path = os.path.join(root, filename)
                      print(f"Uploading {local_path} -> {remote_dir}/{filename}")
                      with open(local_path, "rb") as fp:
                          try:
                              ftp.storbinary(f"STOR {filename}", fp)
                          except Exception as e:
                              raise RuntimeError(f"Failed to upload {local_path}: {e}")

          def main():
              # Clean start
              if os.path.isdir(EXTRACT_DIR):
                  shutil.rmtree(EXTRACT_DIR)

              # 1. Download
              download_zip(ZIP_URL, ZIP_NAME)

              # 2. Extract
              os.makedirs(EXTRACT_DIR, exist_ok=True)
              extract_zip(ZIP_NAME, EXTRACT_DIR)

              # 3. Delete the zip
              remove_file(ZIP_NAME)

              # 4. Upload
              host, port = parse_host_port(FTP_HOST_PORT)
              print(f"Connecting to FTP {host}:{port} as {FTP_USER}")
              ftp = ftplib.FTP()
              ftp.connect(host, port, timeout=30)
              ftp.login(FTP_USER, FTP_PASS)
              print("FTP connected and logged in.")
              try:
                  upload_directory(ftp, EXTRACT_DIR, REMOTE_BASE_DIR)
              finally:
                  try:
                      ftp.quit()
                  except Exception:
                      try:
                          ftp.close()
                      except Exception:
                          pass
              print("Upload finished.")

          if __name__ == "__main__":
              main()
          PY
